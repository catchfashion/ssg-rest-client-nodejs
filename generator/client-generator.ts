// eslint-disable-next-line @typescript-eslint/no-var-requires
const del = require("del");
import * as _ from "lodash";
import * as path from "path";
import * as fs from "fs";

import * as Types from "./types";

import type { Service } from "./service-discovery";

type Node = | {
  name: string;
  type: "list" | "object";
  required: boolean;
  deprecated: boolean;
  children: Node[];
} | {
  name: string;
  required: boolean;
  deprecated: boolean;
  type: "int" | "double" | "string" | "String" | "useYn";
}
type Tree = Node[];

export class ClientGenerator {
  private readonly destination: string;

  constructor(
    private readonly service: Service,
    destination?: string,
  ) {
    this.destination = destination ?? path.resolve(__dirname, "..", "src", "services", `${this.service.name}`);
  }

  public async emit() {
    await del(this.destination);
    await fs.mkdirSync(this.destination);
    await fs.writeFileSync(path.resolve(this.destination, "index.ts"), this.generate());
  }

  private generate() {
    const serviceName = _.chain(this.service.name).camelCase().upperFirst().value();

    const { requestApi, responseApi } = this.service.spec.contents[0].drawItem;
    const [requestApiRootRow, ...requestApiRestRows] = requestApi.prop.simpleRows;
    const requestApiRows = [
      { simpleDatas: requestApiRootRow.simpleDatas, simpleOption: { level: 0 } },
      ...requestApiRestRows,
    ];
    const [responseApiRootRow, ...responseApiRestRows] = responseApi.prop.simpleRows;
    const responseApiRows = [
      { simpleDatas: responseApiRootRow.simpleDatas, simpleOption: { level: 0 } },
      ...responseApiRestRows,
    ];

    const version = this.version();
    const path = this.path();
    const method = this.method();
    const replacedPath = path.replace("{version}", version).replace(/^\/+/, "");

    const RequestParamTypeName = `${serviceName}RequestParams`;
    const ResponseParamTypeName = `${serviceName}ResponseParams`;

    return `
      // THIS FILE IS AUTO-GENERATED. DO NOT EDIT THIS FILE DIRECTLY.
      // Edit generator/client-generator.ts if you want to make any changes.
      import type { Response } from "got";
      import { BaseClient } from "../client";

      export type ${RequestParamTypeName} = { ${this.renderType(this.toTree(requestApiRows))} }

      export type ${ResponseParamTypeName} = { ${this.renderType(this.toTree(responseApiRows))} }

      // render client
      export class Client extends BaseClient {
        public async call(params: ${RequestParamTypeName}): Promise<Response<${ResponseParamTypeName}>> {
          return await this.client<${ResponseParamTypeName}>("${replacedPath}", {
            method: "${method}",
            ${method === "get" ? "searchParams" : "json"}: params,
          });
        }
      }
    `;
  }

  private version(): string {
    const versions = this.service.spec.contents[0].drawItem.requestURI.prop.simpleRows
      .find(({ simpleDatas }) => simpleDatas[0] === "version")
      ?.simpleOption.ko[0]?.versionDesc
      .match(/(\d.\d)/g);
    const version = versions?.length && _.last(versions);

    if (!version) {
      throw Error("API version not specified");
    }
    return version;
  }

  private path(): string {
    const path = this.service.spec.language.ko.apiDesc.match(/Url : (.+.ssg)<br\/>/)?.[1];
    if (!path) {
      throw Error("API path not specified");
    }
    return path;
  }

  private method(): "get" | "post" {
    const method = this.service.spec.language.ko.apiDesc.match(/Method : (\w+)<br\/>/)?.[1]?.toLowerCase();
    if (!method) {
      throw Error("API method not specified");
    }
    if (method !== "get" && method !== "post") {
      throw Error("API method not supported");
    }

    return method;
  }

  private toTree(rows: Types.APIRow[]): Tree {
    const tree: Tree = [];
    
    let index = 0;
    while (index < rows.length) {
      const row = rows[index];
      const [name, type, requireString] = row.simpleDatas;
      const required = requireString === "Y";
      const deprecated = row.simpleOption.isDel === true || row.simpleOption.isDel === "Y";

      switch(type) {
        case "object":
        case "list": {
          const startChildrenIndex = index + 1;
          const lastChildrenIndex = rows
            .slice(startChildrenIndex)
            .findIndex(({ simpleOption: { level } }) => level <= row.simpleOption.level);
          const nextIndex = lastChildrenIndex === -1
            ? rows.length
            : lastChildrenIndex + startChildrenIndex;

          tree.push({
            name, type, required, deprecated,
            children: this.toTree(rows.slice(startChildrenIndex, nextIndex)),
          });
          index = nextIndex;
          continue;
        }
        case "int":
        case "double":
        case "string":
        case "String":
        case "useYn": {
          tree.push({ name, type, required, deprecated });
          index++;
          continue;
        }
        default: {
          tree.push({ name, type: "string", required, deprecated });
          index++;
          console.error(`Not support data type: ${name} - ${type}`);
          continue;
        }
      }
    }

    return tree;
  }

  private renderType(tree: Tree): string {
    return _.chain(tree)
      .map((node) => {
        const { name, required } = node;
        const optionalString = required ? "" : "?";
        
        if (node.deprecated) {
          return null;
        }

        switch(node.type) {
          case "double":
          case "int": {
            return `${name}${optionalString}: number;`;
          }
          case "string":
          case "String": {
            const type = name === "useYn" ? `"Yes" | "No"` : "string";
            return `${name}${optionalString}: ${type};`;
          }
          case "useYn": {
            return `${name}${optionalString}: "Yes" | "No";`;
          }
          case "object": {
            return `${name}${optionalString}: {
              ${this.renderType(node.children)}
            }`;
          }
          case "list": {
            return `${name}${optionalString}: Array<{ ${this.renderType(node.children)} }>;`;
          }
        }
      })
      .compact()
      .join("\n")
      .value();
  }
}
